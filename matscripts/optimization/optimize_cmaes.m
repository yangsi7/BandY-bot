
strat = 1;
if strat == 1
   AllParam = {
                   'rfper',               5,                    35;            ...
                   'rfmult',              0.2,                   3;            ...
                   'rsiper',              5,                    35;            ...
                   'jmaL',                5,                    20;            ...
                   'jmaphi',              5,                    70;            ...
                   'jmapow',              1,                     3;            ...
                   'adxper',              5,                    35;            ...
                   'bollper',             5,                    35;            ...
                   'macdfast',            3,                     15;            ...
                   'macdsignal',          1,                     15;            ...
                   'macdlong',            1,                     15;            ...
                   'sarinc',              0.1,                   0.9;            ...
                   'sarmmax',             0.01,                  0.5;            ...
                   'svolper',             10,                    80;            ...
                   'svolf',               0.1,                     3;            ...
                   'slscale1',            0,                 5;            ...
                   'slscale2',            0.1,                   3;            ...
                   'slscale3',            0,                 5;            ...
                   'slscale4',            0.5,                   3;            ...
                   'slmax',              0.001,                  0.1;            ...
                   'lstop',              0.001,                  0.05;            ...
                   'sstop',              0.001,                  0.05;            ...
                   'adxth',              5,                      80;            ...
                   'rsiobos',            40,                     80;            ...
                   };
elseif strat == 2
   AllParam = {
                   'rfper',               26,                    30;            ...
                   'rfmult',              1.25,                   1.5;            ...
                   'rsiper',              19,                    23;            ...
                   'jmaL',                9,                    11;            ...
                   'jmaphi',              19,                    22;            ...
                   'jmapow',              1.75,                  2.25;            ...
                   'adxper',              13,                    21;            ...
                   'macdfast',            4,                     12;            ...
                   'macdsignal',          1,                     5;            ...
                   'macdlong',            1,                     5;            ...
                   'svolper',             35,                    50;            ...
                   'svolf',               1,                     1.5;            ...
                   'lstop',              0.02,                  0.06;            ...
                   'tp1',                0.005,                  0.009;            ...
                   'tp2',                0.01,                  0.018;            ...
                   'ftp',                0.1,                    0.9;            .../
                   'adxth',              13,                   21;            ...
                   'rsiobos',            48,                     56;            ...
                   };
end

 ParNames = AllParam(:,1);
 nPar = size(ParNames,1); % number of parameters

 ParMin = [AllParam{:,2}]';
 ParMax = [AllParam{:,3}]';


% Initialize final output structure
 Optim.ParNames = ParNames;
 Optim.ParMin = ParMin;
 Optim.ParMax = ParMax;

% NOTES:
% (1) Parameters are normalized by subtracting the min and dividing by
%     a normalization factor, typically the range (so they are b/w 0-1)
%     This is done to allow the CMAES algorithm to work in the space [0 1]
% (2) If needed, remember to add the constraint:
%     Constraints: KDen1 + KDen2 + KDen3 = remin
%     This should be done in the cost function (bgc1d setup step)
%     as an ad-hoc constraint (removes one degree of freedom)
%     Remember to remove the corresponding K from the parameter pool!
%     (suggestion: remove KDen1, since first step drives everuthing)
% Calculates useful quantities for normalization, optimization, etc.
 ParMean = (ParMin + ParMax)/2';
 ParRange = ParMax - ParMin;
 ParNorm = ParRange;
%ParStart = (ParMean - ParMin) ./ ParNorm;
 ParStart = rand(nPar,1);
 ParSigma = ParRange./ParNorm/sqrt(12);

% Options
 optn.EvalParallel = '1';
 optn.LBounds = (ParMin - ParMin) ./ ParNorm;
 optn.UBounds = (ParMax - ParMin) ./ ParNorm;
 optn.MaxFunEvals = 10000;

% Enables parallelization
% Note, the # of cores should be the same as the population size of the CMAES:
% Popul size: 4 + floor(3*log(nPar))
 if strcmp(optn.EvalParallel,'1')
    FunName = 'bgc1d_fc2minimize_cmaes_parallel';
    delete(gcp('nocreate'))
    npar = 4;
    ThisPool = parpool('local',npar);
 else
    FunName = 'bgc1d_fc2minimize_cmaes';
 end
 FunArg.ParNames = ParNames;
 FunArg.ParMin = ParMin;
 FunArg.ParNorm = ParNorm; 
 FunArg.strat = strat;

Rroot='/home/euphotic_/yangino-bot/';
addpath(genpath(Rroot));
[~,TMW]=IngestBinance('rroot',Rroot);
tstart=datetime('01-Oct-2019','Locale','en_US');
tend=datetime('05-Jan-2200','Locale','en_US');
ttime=timerange(tstart,tend,'closed');
tmw = TMW.h(ttime,:);
n = size(tmw,1);
k = 4;
c = cvpartition(n,'KFold',k);

k=5;
validate = 0;

for i = 1 : k
   if validate
      FunArg.tmw = tmw(c.training(i),:);
   else
      FunArg.tmw = tmw;
   end
   % Runs the optimization
   tic;
   [pvarout, pmin, counteval, stopflag, out, bestever] = cmaes(FunName,ParStart,ParSigma,optn,FunArg);

   Optim(i).ParNames = ParNames;
   Optim(i).ParOpt = ParMin + ParNorm .* bestever.x;
   Optim(i).cv = c;

   if validate
      ttmw{1} = tmw(c.test(i),:);
      ttmw{2} = tmw;
   else
      ttmw{1}=tmw;
   end

   for j = 1 : length(ttmw)
      if strat == 1
       [varnames,ttmw{j}] = TA.strat1(ttmw{j},...
            'rfper',    round(Optim(i).ParOpt(1)),...
            'rfmult',   Optim(i).ParOpt(2),...
            'rsiper',   round(Optim(i).ParOpt(3)),...
            'jmaL',     round(Optim(i).ParOpt(4)),...
            'jmaphi',   round(Optim(i).ParOpt(5)),...
            'jmapow',  Optim(i).ParOpt(6),...
            'adxper',   round(Optim(i).ParOpt(7)),...
            'bollper',   round(Optim(i).ParOpt(8)),...
            'macdfast',  round(Optim(i).ParOpt(9)),...
            'macdsignal',round(Optim(i).ParOpt(10)),...
            'macdlong',  round(Optim(i).ParOpt(11)),...
            'sarinc',    Optim(i).ParOpt(12),...
            'sarmmax',   Optim(i).ParOpt(13),...
            'svolper',   round(Optim(i).ParOpt(14)),...
            'svolf',     Optim(i).ParOpt(15)...
            );
      [gains{j}, drawdown{j},SumPerf{j},action{j}] = cryptoSimulation_andyopt(ttmw{j},'strat','Andy','params',4,...
         'reInvest',1,...
         'slscale1', Optim(i).ParOpt(16),...
         'slscale2', Optim(i).ParOpt(17),...
         'slscale3', Optim(i).ParOpt(18),...
         'slscale4', Optim(i).ParOpt(19),...
         'slmax', Optim(i).ParOpt(20),...
         'prelstop', Optim(i).ParOpt(21),...
         'presstop', Optim(i).ParOpt(22),...
         'adxth', Optim(i).ParOpt(23),...
         'rsiobos', Optim(i).ParOpt(24)...
         );
      elseif strat == 2
       [varnames,ttmw{j}] = TA.strat1(ttmw{j},...
            'rfper',    round(Optim(i).ParOpt(1)),...
            'rfmult',   Optim(i).ParOpt(2),...
            'rsiper',   round(Optim(i).ParOpt(3)),...
            'jmaL',     round(Optim(i).ParOpt(4)),...
            'jmaphi',   round(Optim(i).ParOpt(5)),...
            'jmapow',  Optim(i).ParOpt(6),...
            'adxper',   round(Optim(i).ParOpt(7)),...
            'macdfast',  round(Optim(i).ParOpt(8)),...
            'macdsignal',round(Optim(i).ParOpt(9)),...
            'macdlong',  round(Optim(i).ParOpt(10)),...
            'svolper',   round(Optim(i).ParOpt(11)),...
            'svolf',     Optim(i).ParOpt(12)...
            );
      [gains{j}, drawdown{j},SumPerf{j},action{j}] = cryptoSimulation_andyopt(ttmw{j},'strat','Andy2','params',2,...
         'prelstop', Optim(i).ParOpt(13),...
         'presstop', Optim(i).ParOpt(13),...
         'tp1', Optim(i).ParOpt(14),...
         'tp2', Optim(i).ParOpt(15),...
         'ftp', Optim(i).ParOpt(16),...
         'adxth', Optim(i).ParOpt(17),...
         'rsiobos', Optim(i).ParOpt(18)...
         );
      end
      end
   tt = 1;
   if validate 
      tt = tt + 1
      Optim(i).valgains = gains{1};
      Optim(i).valdrawdown=drawdown{1};
      Optim(i).valSumPerf = SumPerf{1};
      Optim(i).valaction = action{1};
      display(['Model ',num2str(i),': val gain = ',num2str(Optim(i).valgains),' / total gain = ', num2str(Optim(i).gains)]);
   end
   
   Optim(i).gains = gains{tt};
   Optim(i).drawdown=drawdown{tt};
   Optim(i).SumPerf = SumPerf{tt};
   Optim(i).action = action{tt};
   
      display(['Model ',num2str(i),': total gain = ', num2str(Optim(i).gains)]);
end

% Stops parallel pool
 if strcmp(optn.EvalParallel,'1')
    delete(ThisPool);
 end

% Fills in some output in final structure
% NOTE: instead of saving last iteration, saves best solution
 % Renormalized parameters
 save('/home/euphotic_/yangino-bot/matscripts/optimization/optimOut/optimoutmulti.mat','Optim');
